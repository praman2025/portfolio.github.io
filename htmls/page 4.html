<!DOCTYPE html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../css/style4.css">
    <title>Sorting Techniques</title>
</head>
<body>
    <header>Sorting Techniques</header>
    <h1>Bubble Sort</h1>
    <p>
        This algorithm repeatedly compares adjacent elements and swaps them if they are in the wrong order. It continues until no swaps are needed, making it inefficient with a time complexity of O(n^2), where n is the number of elements.
    </p>
    <h1>Selection Sort</h1>
    <p>
        Selection Sort repeatedly finds the minimum element in the unsorted part of the list and swaps it with the first unsorted element. It has a time complexity of O(n^2), but unlike Bubble Sort, it makes fewer swaps.
    </p>
    <h1>Insertion Sort</h1>
    <p>
        Insertion Sort builds the final sorted array one element at a time by inserting elements into their correct position in a growing sorted section. Its average and worst-case time complexity is O(n^2), but it performs well on nearly sorted data with a best-case time complexity of O(n).
    </p>
    <h1>
        Merge Sort
    </h1>
    <p>
        Merge Sort is a divide-and-conquer algorithm that splits the list into two halves, sorts them recursively, and then merges the sorted halves. Its time complexity is O(nlogn) in all cases, making it more efficient than O(n^2) algorithms.
    </p>
    <h1>Quick Sort</h1>
    <p>
        Quick Sort is also a divide-and-conquer algorithm that selects a "pivot" element and partitions the list into two sublists, recursively sorting them. On average, its time complexity is O(nlogn), though its worst-case time complexity is O(n^2) when the pivot is poorly chosen.
    </p>
    <h1>Heap Sort</h1>
    <p>
        Heap Sort builds a binary heap from the input data and repeatedly extracts the maximum element to place it in its correct position. It has a time complexity of O(nlogn) and is more space-efficient than Merge Sort, which requires extra space for merging.
    </p>
</body>
</html>